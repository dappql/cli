import { writeFileSync } from 'fs'
import { join } from 'path'
import { RUNNING_DIRECTORY } from '../utils/constants'
import { Config } from '../utils/getConfig'

export function createGetContractFunctions(
  contracts: Config['contracts'],
  target: string,
) {
  const path = join(RUNNING_DIRECTORY, target, 'getContract.ts')
  const keys = Object.keys(contracts).sort()
  const template = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, utils } from 'ethers'

import {
 ${keys.join(',\n ')},
 ${keys.join('__factory,\n ')}__factory
} from './typechain'

type Contracts = {
${keys.map((c) => ` ${c}: ${c}`).join('\n')}
}

const INTERFACES = {
${keys.map((c) => ` ${c}: new utils.Interface(${c}__factory.abi),`).join('\n')}
}

export const MANIFEST: {
  [K in keyof Contracts]: string | Record<number, string>
} = {${keys.map((k) => `"${k}": "${contracts[k]}"`).join(',')}}

export function getAddress<C extends keyof Contracts>(
  contract: C,
  network = 0,
) {
  return (
    (typeof MANIFEST[contract] === 'string'
      ? (MANIFEST[contract] as string)
      : MANIFEST[contract][network]) || ''
  )
}

export default function getContract<C extends keyof Contracts>(
  contract: C,
  network?: number,
) {
  return new Contract(
    getAddress(contract, network),
    INTERFACES[contract],
  ) as Contracts[C]
}

`
  writeFileSync(path, template)
}
